<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no, viewport-fit=cover">
    <meta name="apple-mobile-web-app-capable" content="yes">
    <meta name="apple-mobile-web-app-status-bar-style" content="black-translucent">
    <meta name="theme-color" content="#000">
    <title>Feed</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        html, body {
            height: 100%;
            height: -webkit-fill-available;
            overflow: hidden;
            background: #000;
        }

        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;
            color: #fff;
        }

        /* Home view */
        .home-view {
            min-height: 100%;
            min-height: 100vh;
            min-height: -webkit-fill-available;
            background: #1a1a1a;
            padding: 20px;
            padding-top: calc(env(safe-area-inset-top) + 20px);
            padding-bottom: calc(env(safe-area-inset-bottom) + 20px);
            padding-left: calc(env(safe-area-inset-left) + 20px);
            padding-right: calc(env(safe-area-inset-right) + 20px);
            overflow-y: auto;
            -webkit-overflow-scrolling: touch;
        }

        .header {
            display: flex;
            align-items: center;
            margin-bottom: 20px;
            gap: 12px;
        }

        .header h1 {
            font-size: 24px;
            font-weight: 600;
            flex: 1;
        }

        .sort-select {
            background: #2a2a2a;
            border: 1px solid #3a3a3a;
            color: #e0e0e0;
            padding: 8px 12px;
            border-radius: 8px;
            font-size: 14px;
            outline: none;
            cursor: pointer;
            -webkit-appearance: none;
            appearance: none;
            background-image: url("data:image/svg+xml,%3Csvg xmlns='http://www.w3.org/2000/svg' width='12' height='12' viewBox='0 0 12 12'%3E%3Cpath fill='%23888' d='M6 8L2 4h8z'/%3E%3C/svg%3E");
            background-repeat: no-repeat;
            background-position: right 10px center;
            padding-right: 30px;
        }

        .sort-select:focus {
            border-color: #ff4500;
        }

        .add-row {
            display: flex;
            gap: 10px;
            margin-bottom: 20px;
        }

        .add-row input {
            flex: 1;
            background: #2a2a2a;
            border: 1px solid #3a3a3a;
            color: #e0e0e0;
            padding: 10px 14px;
            border-radius: 8px;
            font-size: 16px;
            outline: none;
        }

        .add-row input::placeholder {
            color: #666;
        }

        .add-row input:focus {
            border-color: #ff4500;
        }

        .add-row button {
            background: #ff4500;
            border: none;
            color: #fff;
            padding: 10px 20px;
            border-radius: 8px;
            font-size: 16px;
            font-weight: 600;
            cursor: pointer;
            flex-shrink: 0;
        }

        .sub-list {
            list-style: none;
        }

        .sub-item {
            display: flex;
            align-items: center;
            padding: 14px 0;
            border-bottom: 1px solid #2a2a2a;
            position: relative;
            overflow: hidden;
            touch-action: pan-y;
        }

        .sub-item-content {
            display: flex;
            align-items: center;
            flex: 1;
            min-width: 0;
            transition: transform 0.2s;
            cursor: pointer;
        }

        .sub-name {
            font-size: 17px;
            font-weight: 500;
            color: #fff;
            flex: 1;
        }

        .sub-name:hover {
            color: #ff4500;
        }

        .sub-arrow {
            color: #555;
            font-size: 18px;
            margin-left: 10px;
        }

        .sub-delete {
            background: none;
            border: none;
            color: #666;
            font-size: 20px;
            cursor: pointer;
            padding: 5px 10px;
            flex-shrink: 0;
        }

        .sub-delete:hover {
            color: #ff4500;
        }

        .sub-delete-bg {
            position: absolute;
            right: 0;
            top: 0;
            bottom: 0;
            background: #d32f2f;
            color: #fff;
            display: flex;
            align-items: center;
            padding: 0 20px;
            font-size: 14px;
            font-weight: 600;
            transform: translateX(100%);
            transition: transform 0.2s;
        }

        /* Feed view */
        .feed-view {
            height: 100%;
            height: 100vh;
            height: -webkit-fill-available;
            display: none;
            flex-direction: column;
            background: #000;
        }

        .feed-view.active {
            display: flex;
        }

        .feed-header {
            position: fixed;
            top: 0;
            left: 0;
            right: 0;
            z-index: 100;
            display: flex;
            align-items: center;
            padding: 12px 16px;
            padding-top: calc(env(safe-area-inset-top) + 12px);
            padding-left: calc(env(safe-area-inset-left) + 16px);
            padding-right: calc(env(safe-area-inset-right) + 16px);
            background: linear-gradient(to bottom, rgba(0,0,0,0.8) 0%, rgba(0,0,0,0) 100%);
            pointer-events: none;
        }

        .feed-header > * {
            pointer-events: auto;
        }

        .back-btn {
            background: rgba(255,255,255,0.15);
            border: none;
            color: #fff;
            width: 40px;
            height: 40px;
            border-radius: 50%;
            font-size: 20px;
            cursor: pointer;
            display: flex;
            align-items: center;
            justify-content: center;
            backdrop-filter: blur(10px);
            -webkit-backdrop-filter: blur(10px);
        }

        .feed-title {
            flex: 1;
            font-size: 17px;
            font-weight: 600;
            text-align: center;
            margin: 0 12px;
            text-shadow: 0 1px 3px rgba(0,0,0,0.5);
        }

        .refresh-btn {
            background: rgba(255,255,255,0.15);
            border: none;
            color: #fff;
            width: 40px;
            height: 40px;
            border-radius: 50%;
            font-size: 18px;
            cursor: pointer;
            display: flex;
            align-items: center;
            justify-content: center;
            backdrop-filter: blur(10px);
            -webkit-backdrop-filter: blur(10px);
        }

        .refresh-btn.spinning {
            animation: spin 1s linear infinite;
        }

        @keyframes spin {
            to { transform: rotate(360deg); }
        }

        /* Feed container with scroll-snap */
        .feed-container {
            flex: 1;
            overflow-y: scroll;
            scroll-snap-type: y mandatory;
            -webkit-overflow-scrolling: touch;
            scrollbar-width: none;
            -ms-overflow-style: none;
        }

        .feed-container::-webkit-scrollbar {
            display: none;
        }

        /* Individual feed item */
        .feed-item {
            height: 100vh;
            height: 100dvh;
            width: 100%;
            scroll-snap-align: start;
            scroll-snap-stop: always;
            position: relative;
            display: flex;
            align-items: center;
            justify-content: center;
            background: #000;
            overflow: hidden;
        }

        .feed-item-media {
            max-width: 100%;
            max-height: 100%;
            width: auto;
            height: auto;
            object-fit: contain;
        }

        .feed-item video {
            max-width: 100%;
            max-height: 100%;
            width: 100%;
            height: 100%;
            object-fit: contain;
        }

        .feed-item-overlay {
            position: absolute;
            bottom: 0;
            left: 0;
            right: 0;
            padding: 60px 16px 20px 16px;
            padding-bottom: calc(env(safe-area-inset-bottom) + 20px);
            padding-left: calc(env(safe-area-inset-left) + 16px);
            padding-right: calc(env(safe-area-inset-right) + 16px);
            background: linear-gradient(to top, rgba(0,0,0,0.8) 0%, rgba(0,0,0,0) 100%);
            pointer-events: none;
        }

        .feed-item-title {
            font-size: 15px;
            font-weight: 500;
            line-height: 1.4;
            margin-bottom: 8px;
            text-shadow: 0 1px 3px rgba(0,0,0,0.5);
            display: -webkit-box;
            -webkit-line-clamp: 3;
            -webkit-box-orient: vertical;
            overflow: hidden;
        }

        .feed-item-meta {
            font-size: 13px;
            color: rgba(255,255,255,0.7);
            display: flex;
            gap: 12px;
            flex-wrap: wrap;
        }

        .feed-item-score {
            color: #ff4500;
            font-weight: 600;
        }

        /* Gallery navigation */
        .gallery-nav {
            position: absolute;
            bottom: calc(env(safe-area-inset-bottom) + 140px);
            background: rgba(255,255,255,0.2);
            border: none;
            color: #fff;
            width: 44px;
            height: 44px;
            border-radius: 50%;
            font-size: 20px;
            cursor: pointer;
            display: flex;
            align-items: center;
            justify-content: center;
            backdrop-filter: blur(10px);
            -webkit-backdrop-filter: blur(10px);
            z-index: 10;
        }

        .gallery-nav.prev {
            left: calc(env(safe-area-inset-left) + 12px);
        }

        .gallery-nav.next {
            right: calc(env(safe-area-inset-right) + 12px);
        }

        .gallery-indicator {
            position: absolute;
            bottom: calc(env(safe-area-inset-bottom) + 150px);
            left: 50%;
            transform: translateX(-50%);
            background: rgba(0,0,0,0.6);
            padding: 6px 12px;
            border-radius: 12px;
            font-size: 13px;
            font-weight: 500;
            z-index: 5;
        }

        /* Loading state */
        .feed-loading {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            display: flex;
            flex-direction: column;
            align-items: center;
            gap: 12px;
        }

        .loading-spinner {
            width: 40px;
            height: 40px;
            border: 3px solid #333;
            border-top-color: #ff4500;
            border-radius: 50%;
            animation: spin 1s linear infinite;
        }

        /* Error state */
        .feed-error {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            text-align: center;
            padding: 20px;
        }

        .feed-error p {
            color: #888;
            margin-bottom: 16px;
        }

        .retry-btn {
            background: #2a2a2a;
            border: 1px solid #3a3a3a;
            color: #fff;
            padding: 12px 24px;
            border-radius: 20px;
            font-size: 15px;
            cursor: pointer;
        }

        /* End of feed */
        .feed-end {
            height: 100vh;
            height: 100dvh;
            scroll-snap-align: start;
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            gap: 16px;
            padding: 20px;
        }

        .feed-end p {
            color: #888;
            font-size: 16px;
        }

        .load-more-btn {
            background: #ff4500;
            border: none;
            color: #fff;
            padding: 14px 32px;
            border-radius: 25px;
            font-size: 16px;
            font-weight: 600;
            cursor: pointer;
        }

        .load-more-btn:disabled {
            opacity: 0.6;
        }

        /* Hidden state */
        .hidden {
            display: none !important;
        }

        /* Empty state */
        .empty-state {
            color: #666;
            text-align: center;
            padding: 40px 20px;
        }

        /* Mixed feed item */
        .mixed-feed-item {
            display: flex;
            align-items: center;
            padding: 16px;
            margin-bottom: 16px;
            background: linear-gradient(135deg, #ff4500 0%, #ff6b35 100%);
            border-radius: 12px;
            cursor: pointer;
            transition: transform 0.15s, opacity 0.15s;
        }

        .mixed-feed-item:active {
            transform: scale(0.98);
            opacity: 0.9;
        }

        .mixed-feed-icon {
            font-size: 24px;
            margin-right: 12px;
        }

        .mixed-feed-text {
            flex: 1;
        }

        .mixed-feed-title {
            font-size: 17px;
            font-weight: 600;
            color: #fff;
        }

        .mixed-feed-subtitle {
            font-size: 13px;
            color: rgba(255,255,255,0.8);
            margin-top: 2px;
        }

        .mixed-feed-arrow {
            color: rgba(255,255,255,0.8);
            font-size: 18px;
        }

        /* Video play button overlay */
        .video-play-overlay {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            width: 80px;
            height: 80px;
            background: rgba(0, 0, 0, 0.6);
            border-radius: 50%;
            display: flex;
            align-items: center;
            justify-content: center;
            cursor: pointer;
            opacity: 0;
            transition: opacity 0.2s;
            pointer-events: none;
            z-index: 5;
        }

        .video-play-overlay.visible {
            opacity: 1;
            pointer-events: auto;
        }

        .video-play-overlay::after {
            content: '';
            width: 0;
            height: 0;
            border-style: solid;
            border-width: 15px 0 15px 25px;
            border-color: transparent transparent transparent #fff;
            margin-left: 5px;
        }

        /* Media error state */
        .media-error {
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            gap: 12px;
            color: #666;
        }

        .media-error-icon {
            font-size: 48px;
            opacity: 0.5;
        }

        .skip-btn {
            background: rgba(255,255,255,0.1);
            border: 1px solid #444;
            color: #fff;
            padding: 10px 20px;
            border-radius: 20px;
            font-size: 14px;
            cursor: pointer;
        }
    </style>
</head>
<body>
    <div class="home-view" id="home-view">
        <div class="header">
            <h1>Feed</h1>
            <select class="sort-select" id="sort-select">
                <option value="hot">Hot</option>
                <option value="new">New</option>
                <option value="top">Top</option>
                <option value="rising">Rising</option>
            </select>
        </div>
        <div class="add-row">
            <input type="text" id="sub-input" placeholder="Add subreddit..." autocapitalize="none" autocorrect="off">
            <button id="add-btn">Add</button>
        </div>
        <ul class="sub-list" id="sub-list"></ul>
    </div>

    <div class="feed-view" id="feed-view">
        <div class="feed-header">
            <button class="back-btn" id="back-btn">&larr;</button>
            <span class="feed-title" id="feed-title">r/pics</span>
            <button class="refresh-btn" id="refresh-btn">&#x21bb;</button>
        </div>
        <div class="feed-container" id="feed-container"></div>
    </div>

    <script>
        const PROXY = 'https://little-sunset-822a.maattp.workers.dev/';
        const LS_KEY = 'feed-subs';
        const LS_SORT_KEY = 'feed-sort';
        const DEFAULT_SUBS = ['pics', 'videos', 'gifs', 'aww'];
        const SORT_OPTIONS = ['hot', 'new', 'top', 'rising'];

        let state = {
            view: 'home',
            sub: null,
            isMixed: false,
            posts: [],
            after: null,
            currentIndex: 0,
            loading: false,
            sort: localStorage.getItem(LS_SORT_KEY) || 'hot'
        };

        // Windowed rendering settings
        const WINDOW_BEFORE = 2;  // Items to keep before current
        const WINDOW_AFTER = 3;   // Items to keep after current
        let currentWindow = { start: 0, end: 0 };

        // Single observer instance to avoid memory leaks
        let feedObserver = null;

        function getSubs() {
            try {
                const stored = localStorage.getItem(LS_KEY);
                if (stored) {
                    const parsed = JSON.parse(stored);
                    if (Array.isArray(parsed)) return parsed;
                }
            } catch (e) {
                // Corrupted localStorage, reset to defaults
            }
            localStorage.setItem(LS_KEY, JSON.stringify(DEFAULT_SUBS));
            return [...DEFAULT_SUBS];
        }

        function saveSubs(subs) {
            try {
                localStorage.setItem(LS_KEY, JSON.stringify(subs));
            } catch (e) {
                // localStorage full or unavailable
            }
        }

        async function redditFetch(path, retries = 3) {
            const url = `${PROXY}?url=${encodeURIComponent('https://www.reddit.com' + path)}`;
            let lastError;
            for (let attempt = 0; attempt < retries; attempt++) {
                try {
                    if (attempt > 0) {
                        await new Promise(r => setTimeout(r, 1000 * Math.pow(2, attempt - 1)));
                    }
                    const res = await fetch(url);
                    if (res.status === 429) {
                        const err = new Error('Rate limited');
                        err.status = 429;
                        throw err;
                    }
                    if (!res.ok) throw new Error(res.status);
                    return res.json();
                } catch (err) {
                    lastError = err;
                    if (err.status === 429) break; // Don't retry rate limits
                }
            }
            throw lastError;
        }

        function timeAgo(utc) {
            const seconds = Math.floor(Date.now() / 1000 - utc);
            if (seconds < 0) return 'just now'; // Handle future timestamps (clock skew)
            if (seconds < 60) return 'just now';
            if (seconds < 3600) return Math.floor(seconds / 60) + 'm';
            if (seconds < 86400) return Math.floor(seconds / 3600) + 'h';
            if (seconds < 604800) return Math.floor(seconds / 86400) + 'd';
            return Math.floor(seconds / 604800) + 'w';
        }

        function formatScore(n) {
            if (n >= 100000) return (n / 1000).toFixed(0) + 'k';
            if (n >= 10000) return (n / 1000).toFixed(1) + 'k';
            if (n >= 1000) return (n / 1000).toFixed(1) + 'k';
            return String(n);
        }

        function escapeHtml(s) {
            const d = document.createElement('div');
            d.textContent = s;
            return d.innerHTML;
        }

        // Extract media info from a Reddit post
        function extractMedia(post) {
            const media = {
                type: null,
                url: null,
                urls: null,  // For galleries
                thumbnail: null,
                width: 0,
                height: 0
            };

            // Reddit hosted video (check both media and secure_media)
            const redditVideo = post.media?.reddit_video || post.secure_media?.reddit_video;
            if (post.is_video && redditVideo) {
                media.type = 'video';
                media.url = redditVideo.fallback_url;
                media.width = redditVideo.width;
                media.height = redditVideo.height;
                return media;
            }

            // Cross-post with video
            if (post.crosspost_parent_list?.length > 0) {
                const parent = post.crosspost_parent_list[0];
                const parentVideo = parent.media?.reddit_video || parent.secure_media?.reddit_video;
                if (parent.is_video && parentVideo) {
                    media.type = 'video';
                    media.url = parentVideo.fallback_url;
                    media.width = parentVideo.width;
                    media.height = parentVideo.height;
                    return media;
                }
            }

            // Gallery posts
            if (post.is_gallery && post.gallery_data?.items && post.media_metadata) {
                const items = post.gallery_data.items;
                const urls = [];
                for (const item of items) {
                    const meta = post.media_metadata[item.media_id];
                    if (meta && meta.s && meta.status !== 'failed') {
                        // Get the highest quality image
                        let imgUrl = meta.s.u || meta.s.gif;
                        if (imgUrl) {
                            // Decode HTML entities in URL
                            imgUrl = imgUrl.replace(/&amp;/g, '&');
                            urls.push({
                                url: imgUrl,
                                width: meta.s.x,
                                height: meta.s.y
                            });
                        }
                    }
                }
                if (urls.length > 0) {
                    media.type = 'gallery';
                    media.urls = urls;
                    media.url = urls[0].url;
                    media.width = urls[0].width;
                    media.height = urls[0].height;
                    return media;
                }
            }

            // GIF from preview (reddit serves as mp4)
            if (post.preview?.reddit_video_preview) {
                media.type = 'video';
                media.url = post.preview.reddit_video_preview.fallback_url;
                media.width = post.preview.reddit_video_preview.width;
                media.height = post.preview.reddit_video_preview.height;
                return media;
            }

            // Check for mp4 variant in preview images
            if (post.preview?.images?.[0]?.variants?.mp4) {
                const mp4 = post.preview.images[0].variants.mp4.source;
                media.type = 'video';
                media.url = mp4.url.replace(/&amp;/g, '&');
                media.width = mp4.width;
                media.height = mp4.height;
                return media;
            }

            // Check for gif variant in preview images
            if (post.preview?.images?.[0]?.variants?.gif) {
                const gif = post.preview.images[0].variants.gif.source;
                media.type = 'image';
                media.url = gif.url.replace(/&amp;/g, '&');
                media.width = gif.width;
                media.height = gif.height;
                return media;
            }

            // Regular image post
            if (post.post_hint === 'image' ||
                /\.(jpg|jpeg|png|gif|webp)(\?.*)?$/i.test(post.url)) {
                media.type = 'image';
                media.url = post.url.replace(/&amp;/g, '&');
                if (post.preview?.images?.[0]?.source) {
                    media.width = post.preview.images[0].source.width;
                    media.height = post.preview.images[0].source.height;
                }
                return media;
            }

            // External video hosts (YouTube, etc.) - skip, can't autoplay
            if (post.post_hint === 'rich:video') {
                return null;
            }

            // Fallback to preview image if available
            if (post.preview?.images?.[0]?.source) {
                const src = post.preview.images[0].source;
                media.type = 'image';
                media.url = src.url.replace(/&amp;/g, '&');
                media.width = src.width;
                media.height = src.height;
                return media;
            }

            return null;
        }

        // Calculate the window range around current index
        function getWindowRange(currentIndex) {
            const start = Math.max(0, currentIndex - WINDOW_BEFORE);
            const end = Math.min(state.posts.length - 1, currentIndex + WINDOW_AFTER);
            return { start, end };
        }

        // Check if window needs to shift
        function shouldShiftWindow(currentIndex) {
            // Shift if current is within 1 of window edge
            return currentIndex <= currentWindow.start + 1 || currentIndex >= currentWindow.end - 1;
        }

        // Skip to next feed item
        function skipToNext(currentIndex) {
            const container = document.getElementById('feed-container');
            const nextItem = container.querySelector(`.feed-item[data-index="${currentIndex + 1}"]`);
            if (nextItem) {
                nextItem.scrollIntoView({ behavior: 'smooth' });
            }
        }

        // Handle media error - show error state with skip button
        function handleMediaError(feedItem, index) {
            const mediaEl = feedItem.querySelector('.feed-item-media');
            if (mediaEl) {
                mediaEl.style.display = 'none';
            }

            // Check if error state already exists
            if (feedItem.querySelector('.media-error')) return;

            const errorDiv = document.createElement('div');
            errorDiv.className = 'media-error';
            errorDiv.innerHTML = `
                <div class="media-error-icon">‚ö†Ô∏è</div>
                <p>Failed to load media</p>
                <button class="skip-btn" data-action="skip" data-index="${index}">Skip to Next</button>
            `;
            feedItem.insertBefore(errorDiv, feedItem.querySelector('.feed-item-overlay'));

            // Auto-skip after 2 seconds
            setTimeout(() => {
                if (state.currentIndex === index) {
                    skipToNext(index);
                }
            }, 2000);
        }

        // Render home view
        function renderHome() {
            const subs = getSubs();
            const list = document.getElementById('sub-list');

            // Set sort select to current value
            const sortSelect = document.getElementById('sort-select');
            sortSelect.value = state.sort;

            // Build mixed feed item if we have subreddits
            const mixedHtml = subs.length > 0 ? `
                <div class="mixed-feed-item" id="mixed-feed-btn">
                    <span class="mixed-feed-icon">üîÄ</span>
                    <div class="mixed-feed-text">
                        <div class="mixed-feed-title">Mixed Feed</div>
                        <div class="mixed-feed-subtitle">Posts from all your subreddits</div>
                    </div>
                    <span class="mixed-feed-arrow">&rsaquo;</span>
                </div>
            ` : '';

            if (subs.length === 0) {
                list.innerHTML = '<li class="empty-state">No subreddits yet. Add one above.</li>';
            } else {
                list.innerHTML = mixedHtml + subs.map(s => `
                    <li class="sub-item" data-sub="${escapeHtml(s)}">
                        <div class="sub-delete-bg">Delete</div>
                        <div class="sub-item-content">
                            <span class="sub-name">r/${escapeHtml(s)}</span>
                            <span class="sub-arrow">&rsaquo;</span>
                        </div>
                        <button class="sub-delete" title="Delete">&times;</button>
                    </li>
                `).join('');
            }

            bindHomeEvents();

            document.getElementById('home-view').classList.remove('hidden');
            document.getElementById('feed-view').classList.remove('active');
            state.view = 'home';
            history.replaceState({ view: 'home' }, '', '/apps/feed/');
        }

        function bindHomeEvents() {
            const input = document.getElementById('sub-input');
            const addBtn = document.getElementById('add-btn');

            // Remove old listeners by cloning
            const newInput = input.cloneNode(true);
            const newAddBtn = addBtn.cloneNode(true);
            input.parentNode.replaceChild(newInput, input);
            addBtn.parentNode.replaceChild(newAddBtn, addBtn);

            function addSub() {
                const val = newInput.value.trim().replace(/^r\//, '').replace(/\//g, '').toLowerCase();
                if (!val) return;
                const subs = getSubs();
                if (subs.includes(val)) {
                    newInput.value = '';
                    return;
                }
                subs.push(val);
                saveSubs(subs);
                newInput.value = '';
                renderHome();
            }

            newAddBtn.addEventListener('click', addSub);
            newInput.addEventListener('keydown', e => {
                if (e.key === 'Enter') addSub();
            });

            // Mixed feed button
            const mixedBtn = document.getElementById('mixed-feed-btn');
            if (mixedBtn) {
                mixedBtn.addEventListener('click', openMixedFeed);
            }

            // Delete buttons
            document.querySelectorAll('.sub-delete').forEach(btn => {
                btn.addEventListener('click', e => {
                    e.stopPropagation();
                    const sub = btn.closest('.sub-item').dataset.sub;
                    const subs = getSubs().filter(s => s !== sub);
                    saveSubs(subs);
                    renderHome();
                });
            });

            // Tap to navigate
            document.querySelectorAll('.sub-item-content').forEach(el => {
                el.addEventListener('click', () => {
                    const sub = el.closest('.sub-item').dataset.sub;
                    openFeed(sub);
                });
            });

            // Swipe to delete
            document.querySelectorAll('.sub-item').forEach(item => {
                let startX = 0;
                let currentX = 0;
                let swiping = false;

                item.addEventListener('touchstart', e => {
                    startX = e.touches[0].clientX;
                    currentX = startX;
                    swiping = true;
                }, { passive: true });

                item.addEventListener('touchmove', e => {
                    if (!swiping) return;
                    currentX = e.touches[0].clientX;
                    const diff = startX - currentX;
                    if (diff > 0) {
                        const translate = Math.min(diff, 80);
                        item.querySelector('.sub-item-content').style.transform = `translateX(-${translate}px)`;
                        item.querySelector('.sub-delete-bg').style.transform = `translateX(${Math.max(0, 80 - diff)}px)`;
                    }
                }, { passive: true });

                item.addEventListener('touchend', () => {
                    if (!swiping) return;
                    swiping = false;
                    const diff = startX - currentX;
                    const content = item.querySelector('.sub-item-content');
                    const bg = item.querySelector('.sub-delete-bg');

                    if (diff > 60) {
                        content.style.transform = 'translateX(-80px)';
                        bg.style.transform = 'translateX(0)';
                        bg.addEventListener('click', () => {
                            const sub = item.dataset.sub;
                            const subs = getSubs().filter(s => s !== sub);
                            saveSubs(subs);
                            renderHome();
                        }, { once: true });
                    } else {
                        content.style.transform = '';
                        bg.style.transform = '';
                    }
                });
            });
        }

        // Common setup for feed view
        function setupFeedView(title, historyPath, historyState) {
            state.posts = [];
            state.after = null;
            state.currentIndex = 0;
            cleanupObserver();

            document.getElementById('home-view').classList.add('hidden');
            document.getElementById('feed-view').classList.add('active');
            document.getElementById('feed-title').textContent = title;
            state.view = 'feed';
            history.pushState(historyState, '', historyPath);

            const container = document.getElementById('feed-container');
            container.innerHTML = `
                <div class="feed-item">
                    <div class="feed-loading">
                        <div class="loading-spinner"></div>
                        <p>Loading...</p>
                    </div>
                </div>
            `;
        }

        // Open feed for subreddit
        async function openFeed(sub) {
            state.sub = sub;
            state.isMixed = false;
            setupFeedView(`r/${sub}`, `/apps/feed/#r/${sub}`, { view: 'feed', sub });

            try {
                await loadPosts();
                renderFeed();
            } catch (err) {
                const msg = err.status === 429
                    ? 'Rate limited by Reddit. Wait a minute and try again.'
                    : 'Failed to load posts';
                showFeedError(msg, () => openFeed(sub));
            }
        }

        // Open mixed feed from all subreddits
        async function openMixedFeed() {
            state.sub = null;
            state.isMixed = true;
            setupFeedView('Mixed Feed', '/apps/feed/#mixed', { view: 'feed', mixed: true });

            try {
                await loadMixedPosts();
                renderFeed();
            } catch (err) {
                const msg = err.status === 429
                    ? 'Rate limited by Reddit. Wait a minute and try again.'
                    : 'Failed to load posts';
                showFeedError(msg, () => openMixedFeed());
            }
        }

        function showFeedError(message, retryFn) {
            const container = document.getElementById('feed-container');
            container.innerHTML = `
                <div class="feed-item">
                    <div class="feed-error">
                        <p>${escapeHtml(message)}</p>
                        <button class="retry-btn" id="error-retry-btn">Try Again</button>
                    </div>
                </div>
            `;
            document.getElementById('error-retry-btn').addEventListener('click', retryFn);
        }

        // Fetch posts from a single subreddit
        async function fetchSubredditPosts(subreddit, limit = 50, after = null) {
            let path = `/r/${encodeURIComponent(subreddit)}/${state.sort}.json?limit=${limit}&raw_json=1`;
            if (after) path += `&after=${after}`;

            const data = await redditFetch(path);
            const posts = data.data.children
                .map(c => c.data)
                .map(post => {
                    post.media = extractMedia(post);
                    post.subreddit_display = post.subreddit; // Keep track of source
                    return post;
                })
                .filter(post => post.media !== null);

            return { posts, after: data.data.after };
        }

        // Load posts for mixed feed from a random subreddit
        async function loadMixedPosts() {
            if (state.loading) return;
            state.loading = true;

            try {
                const subs = getSubs();
                if (subs.length === 0) return;

                // Pick one random subreddit
                const randomSub = subs[Math.floor(Math.random() * subs.length)];

                const { posts, after } = await fetchSubredditPosts(randomSub, 15);
                state.posts = state.posts.concat(posts);
                // Always allow loading more (from another random sub)
                state.after = subs.length > 0 ? 'mixed' : null;
            } finally {
                state.loading = false;
            }
        }

        // Load posts for a single subreddit
        async function loadPosts() {
            if (state.loading) return;
            state.loading = true;

            try {
                const { posts, after } = await fetchSubredditPosts(state.sub, 50, state.after);
                state.posts = state.posts.concat(posts);
                state.after = after;
            } finally {
                state.loading = false;
            }
        }

        function cleanupObserver() {
            if (feedObserver) {
                feedObserver.disconnect();
                feedObserver = null;
            }
        }

        function renderFeed() {
            const container = document.getElementById('feed-container');
            cleanupObserver();

            if (state.posts.length === 0) {
                container.innerHTML = `
                    <div class="feed-item">
                        <div class="feed-error">
                            <p>No media posts found</p>
                            <button class="retry-btn" id="go-back-btn">Go Back</button>
                        </div>
                    </div>
                `;
                document.getElementById('go-back-btn').addEventListener('click', goHome);
                return;
            }

            // Initialize window and render
            currentWindow = getWindowRange(state.currentIndex);
            renderWindow();

            // Set up scroll observer for window shifts and video control
            setupScrollObserver();
        }

        // Render only the windowed items with spacers
        function renderWindow() {
            const container = document.getElementById('feed-container');
            const { start, end } = currentWindow;

            // Clean up videos outside new window before re-rendering
            container.querySelectorAll('video').forEach(v => {
                const itemIndex = parseInt(v.closest('.feed-item')?.dataset.index);
                if (isNaN(itemIndex) || itemIndex < start || itemIndex > end) {
                    v.pause();
                    v.removeAttribute('src');
                    v.load();
                }
            });

            // Build HTML with spacers
            const topSpacerHeight = start * 100;
            const bottomSpacerHeight = Math.max(0, state.posts.length - 1 - end) * 100;

            let html = `<div class="feed-spacer" style="height: ${topSpacerHeight}dvh; flex-shrink: 0;"></div>`;

            for (let i = start; i <= end; i++) {
                html += renderFeedItem(state.posts[i], i);
            }

            // Add end of feed indicator if no more posts and we're at the end
            if (!state.after && end === state.posts.length - 1) {
                html += `
                    <div class="feed-end" id="feed-end">
                        <p>That's all for now!</p>
                    </div>
                `;
            } else {
                html += `<div class="feed-spacer" style="height: ${bottomSpacerHeight}dvh; flex-shrink: 0;"></div>`;
            }

            container.innerHTML = html;

            // Bind media error handlers
            bindMediaErrorHandlers();

            // Eagerly load all videos in window
            container.querySelectorAll('video').forEach(v => {
                v.load();
            });
        }

        function renderFeedItem(post, index) {
            const media = post.media;
            let mediaHtml = '';
            let galleryNav = '';

            // All items in window load eagerly since we control what's in DOM
            const loadingAttr = 'eager';

            if (media.type === 'video') {
                // Always start muted for autoplay compatibility, then unmute after play starts
                mediaHtml = `
                    <video class="feed-item-media"
                           data-index="${index}"
                           src="${escapeHtml(media.url)}"
                           autoplay
                           loop
                           muted
                           playsinline
                           preload="auto"
                           webkit-playsinline
                           poster="${post.thumbnail && post.thumbnail !== 'default' ? escapeHtml(post.thumbnail) : ''}">
                    </video>
                    <div class="video-play-overlay" data-index="${index}"></div>
                `;
            } else if (media.type === 'gallery') {
                mediaHtml = `
                    <img class="feed-item-media gallery-image"
                         data-index="${index}"
                         data-gallery-index="0"
                         src="${escapeHtml(media.urls[0].url)}"
                         alt="${escapeHtml(post.title)}"
                         loading="${loadingAttr}">
                `;
                if (media.urls.length > 1) {
                    galleryNav = `
                        <button class="gallery-nav prev" data-index="${index}" style="display:none">&lsaquo;</button>
                        <button class="gallery-nav next" data-index="${index}">&rsaquo;</button>
                        <div class="gallery-indicator" data-index="${index}">1 / ${media.urls.length}</div>
                    `;
                }
            } else {
                mediaHtml = `
                    <img class="feed-item-media"
                         data-index="${index}"
                         src="${escapeHtml(media.url)}"
                         alt="${escapeHtml(post.title)}"
                         loading="${loadingAttr}">
                `;
            }

            const subredditMeta = state.isMixed ? `<span>r/${escapeHtml(post.subreddit)}</span>` : '';

            return `
                <div class="feed-item" data-index="${index}" data-post-id="${post.id}">
                    ${mediaHtml}
                    ${galleryNav}
                    <div class="feed-item-overlay">
                        <div class="feed-item-title">${escapeHtml(post.title)}</div>
                        <div class="feed-item-meta">
                            ${subredditMeta}
                            <span class="feed-item-score">${formatScore(post.score)} pts</span>
                            <span>u/${escapeHtml(post.author)}</span>
                            <span>${timeAgo(post.created_utc)}</span>
                            <span>${post.num_comments} comments</span>
                        </div>
                    </div>
                </div>
            `;
        }

        // Bind error handlers to all media elements
        function bindMediaErrorHandlers() {
            const container = document.getElementById('feed-container');

            // Images
            container.querySelectorAll('img.feed-item-media').forEach(img => {
                img.onerror = function() {
                    const feedItem = this.closest('.feed-item');
                    const index = parseInt(feedItem.dataset.index);
                    handleMediaError(feedItem, index);
                };
            });

            // Videos
            container.querySelectorAll('video.feed-item-media').forEach(video => {
                video.onerror = function() {
                    const feedItem = this.closest('.feed-item');
                    const index = parseInt(feedItem.dataset.index);
                    handleMediaError(feedItem, index);
                };

                // Show/hide play button based on video state
                const feedItem = video.closest('.feed-item');
                const playOverlay = feedItem.querySelector('.video-play-overlay');
                if (playOverlay) {
                    // Show play button when video is paused and visible
                    video.addEventListener('pause', () => {
                        if (state.currentIndex === parseInt(feedItem.dataset.index)) {
                            playOverlay.classList.add('visible');
                        }
                    });

                    video.addEventListener('play', () => {
                        playOverlay.classList.remove('visible');
                    });

                    // Initially check if video is paused after a short delay
                    setTimeout(() => {
                        if (video.paused && state.currentIndex === parseInt(feedItem.dataset.index)) {
                            playOverlay.classList.add('visible');
                        }
                    }, 500);
                }
            });
        }

        function setupScrollObserver() {
            const container = document.getElementById('feed-container');
            const items = container.querySelectorAll('.feed-item[data-index]');

            feedObserver = new IntersectionObserver((entries) => {
                entries.forEach(entry => {
                    const item = entry.target;
                    const index = parseInt(item.dataset.index);
                    const video = item.querySelector('video');

                    if (entry.isIntersecting && entry.intersectionRatio > 0.5) {
                        state.currentIndex = index;

                        // Play video if visible (always muted for iOS autoplay compatibility)
                        if (video) {
                            const playPromise = video.play();
                            if (playPromise !== undefined) {
                                playPromise.catch(err => {
                                    console.log('Video play failed:', err.name, err.message);
                                    if (video.readyState < 2) {
                                        video.addEventListener('canplay', () => {
                                            video.play().catch(() => {});
                                        }, { once: true });
                                    }
                                });
                            }
                        }

                        // Check if we need to shift the window
                        if (shouldShiftWindow(index)) {
                            shiftWindow(index);
                        }

                        // Auto-load more when near end of available posts
                        if (index >= state.posts.length - 5 && state.after && !state.loading) {
                            const loadFn = state.isMixed ? loadMixedPosts : loadPosts;
                            loadFn().catch(() => {});
                        }
                    } else {
                        // Pause video when not visible
                        if (video) {
                            video.pause();
                            // Hide play overlay when scrolling away
                            const playOverlay = item.querySelector('.video-play-overlay');
                            if (playOverlay) {
                                playOverlay.classList.remove('visible');
                            }
                        }
                    }
                });
            }, {
                threshold: [0, 0.5, 1]
            });

            items.forEach(item => feedObserver.observe(item));
        }

        // Shift the window and re-render
        function shiftWindow(currentIndex) {
            const newWindow = getWindowRange(currentIndex);

            // Don't shift if window hasn't actually changed
            if (newWindow.start === currentWindow.start && newWindow.end === currentWindow.end) {
                return;
            }

            // Store scroll position relative to current item
            const container = document.getElementById('feed-container');
            const currentItem = container.querySelector(`.feed-item[data-index="${currentIndex}"]`);
            const currentItemTop = currentItem ? currentItem.getBoundingClientRect().top : 0;

            // Update window and re-render
            currentWindow = newWindow;
            renderWindow();

            // Restore scroll position
            const newCurrentItem = container.querySelector(`.feed-item[data-index="${currentIndex}"]`);
            if (newCurrentItem) {
                const newItemTop = newCurrentItem.getBoundingClientRect().top;
                container.scrollTop += (newItemTop - currentItemTop);
            }

            // Re-setup observer for new items
            setupScrollObserver();
        }

        // No longer needed - windowed rendering handles this automatically
        // New posts are picked up when shiftWindow recalculates the range

        function goHome() {
            // Stop all videos and release resources
            document.querySelectorAll('video').forEach(v => {
                v.pause();
                v.removeAttribute('src');
                v.load();
            });

            cleanupObserver();
            renderHome();
        }

        // Event listeners
        document.getElementById('back-btn').addEventListener('click', goHome);

        // Sort select listener
        document.getElementById('sort-select').addEventListener('change', function() {
            state.sort = this.value;
            localStorage.setItem(LS_SORT_KEY, state.sort);
        });

        document.getElementById('refresh-btn').addEventListener('click', async function() {
            if (state.loading) return;
            this.classList.add('spinning');
            state.posts = [];
            state.after = null;
            state.currentIndex = 0;
            cleanupObserver();

            try {
                const loadFn = state.isMixed ? loadMixedPosts : loadPosts;
                await loadFn();
                renderFeed();
                document.getElementById('feed-container').scrollTop = 0;
            } catch (err) {
                const msg = err.status === 429
                    ? 'Rate limited by Reddit. Wait a minute and try again.'
                    : 'Failed to refresh';
                const retryFn = state.isMixed ? openMixedFeed : () => openFeed(state.sub);
                showFeedError(msg, retryFn);
            } finally {
                this.classList.remove('spinning');
            }
        });

        // Event delegation for feed container (handles gallery nav, skip buttons, video tap)
        document.getElementById('feed-container').addEventListener('click', (e) => {
            const target = e.target;

            // Handle skip button
            if (target.dataset.action === 'skip') {
                const index = parseInt(target.dataset.index);
                skipToNext(index);
                return;
            }

            // Handle gallery navigation
            if (target.classList.contains('gallery-nav')) {
                e.stopPropagation();
                const index = parseInt(target.dataset.index);
                const post = state.posts[index];
                if (!post) return;

                const feedItem = target.closest('.feed-item');
                const img = feedItem.querySelector('.gallery-image');
                const indicator = feedItem.querySelector('.gallery-indicator');
                const prevBtn = feedItem.querySelector('.gallery-nav.prev');
                const nextBtn = feedItem.querySelector('.gallery-nav.next');

                let galleryIndex = parseInt(img.dataset.galleryIndex);
                const totalImages = post.media.urls.length;

                if (target.classList.contains('prev')) {
                    galleryIndex = Math.max(0, galleryIndex - 1);
                } else {
                    galleryIndex = Math.min(totalImages - 1, galleryIndex + 1);
                }

                img.src = post.media.urls[galleryIndex].url;
                img.dataset.galleryIndex = galleryIndex;
                indicator.textContent = `${galleryIndex + 1} / ${totalImages}`;

                prevBtn.style.display = galleryIndex === 0 ? 'none' : 'flex';
                nextBtn.style.display = galleryIndex === totalImages - 1 ? 'none' : 'flex';
                return;
            }

            // Handle play overlay click
            if (target.classList.contains('video-play-overlay')) {
                const feedItem = target.closest('.feed-item');
                const video = feedItem.querySelector('video');
                if (video) {
                    video.play().catch(() => {});
                }
                return;
            }

            // Handle video tap to play/pause
            const feedItem = target.closest('.feed-item');
            if (!feedItem) return;

            // Don't toggle if clicking on buttons
            if (target.closest('button')) return;

            const video = feedItem.querySelector('video');
            if (video) {
                if (video.paused) {
                    video.play().catch(() => {});
                } else {
                    video.pause();
                }
            }
        });

        // Handle browser back/forward
        window.addEventListener('popstate', e => {
            const s = e.state;
            if (!s || s.view === 'home') {
                // Stop videos before going home
                document.querySelectorAll('video').forEach(v => {
                    v.pause();
                    v.removeAttribute('src');
                    v.load();
                });
                cleanupObserver();

                // Re-render home to ensure fresh subreddit list
                renderHome();
            } else if (s.view === 'feed') {
                if (s.mixed) {
                    openMixedFeed();
                } else if (s.sub) {
                    openFeed(s.sub);
                }
            }
        });

        // Initialize
        renderHome();
    </script>
</body>
</html>
