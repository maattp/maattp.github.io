<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no, viewport-fit=cover">
    <meta name="apple-mobile-web-app-capable" content="yes">
    <meta name="apple-mobile-web-app-status-bar-style" content="black-translucent">
    <meta name="theme-color" content="#000">
    <title>Feed</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        html, body {
            height: 100%;
            height: -webkit-fill-available;
            overflow: hidden;
            background: #000;
        }

        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;
            color: #fff;
        }

        /* Home view */
        .home-view {
            position: fixed;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background: #1a1a1a;
            padding: 20px;
            padding-top: calc(env(safe-area-inset-top) + 20px);
            padding-bottom: calc(env(safe-area-inset-bottom) + 20px);
            padding-left: calc(env(safe-area-inset-left) + 20px);
            padding-right: calc(env(safe-area-inset-right) + 20px);
            overflow-y: auto;
            -webkit-overflow-scrolling: touch;
        }

        .header {
            display: flex;
            align-items: center;
            margin-bottom: 20px;
            gap: 12px;
        }

        .header h1 {
            font-size: 24px;
            font-weight: 600;
            flex: 1;
        }

        .version {
            font-size: 12px;
            color: #666;
            font-weight: 400;
            margin-left: 8px;
        }

        .sort-select {
            background: #2a2a2a;
            border: 1px solid #3a3a3a;
            color: #e0e0e0;
            padding: 8px 12px;
            border-radius: 8px;
            font-size: 14px;
            outline: none;
            cursor: pointer;
            -webkit-appearance: none;
            appearance: none;
            background-image: url("data:image/svg+xml,%3Csvg xmlns='http://www.w3.org/2000/svg' width='12' height='12' viewBox='0 0 12 12'%3E%3Cpath fill='%23888' d='M6 8L2 4h8z'/%3E%3C/svg%3E");
            background-repeat: no-repeat;
            background-position: right 10px center;
            padding-right: 30px;
        }

        .sort-select:focus {
            border-color: #ff4500;
        }

        .time-select {
            display: none;
        }

        .time-select.visible {
            display: block;
        }

        .add-row {
            display: flex;
            gap: 10px;
            margin-bottom: 20px;
        }

        .add-row input {
            flex: 1;
            background: #2a2a2a;
            border: 1px solid #3a3a3a;
            color: #e0e0e0;
            padding: 10px 14px;
            border-radius: 8px;
            font-size: 16px;
            outline: none;
        }

        .add-row input::placeholder {
            color: #666;
        }

        .add-row input:focus {
            border-color: #ff4500;
        }

        .add-row button {
            background: #ff4500;
            border: none;
            color: #fff;
            padding: 10px 20px;
            border-radius: 8px;
            font-size: 16px;
            font-weight: 600;
            cursor: pointer;
            flex-shrink: 0;
        }

        .sub-list {
            list-style: none;
        }

        .sub-item {
            display: flex;
            align-items: center;
            padding: 14px 0;
            border-bottom: 1px solid #2a2a2a;
            position: relative;
            overflow: hidden;
            touch-action: pan-y;
        }

        .sub-item-content {
            display: flex;
            align-items: center;
            flex: 1;
            min-width: 0;
            transition: transform 0.2s;
            cursor: pointer;
        }

        .sub-name {
            font-size: 17px;
            font-weight: 500;
            color: #fff;
            flex: 1;
        }

        .sub-name:hover {
            color: #ff4500;
        }

        .sub-arrow {
            color: #555;
            font-size: 18px;
            margin-left: 10px;
        }

        .sub-delete {
            background: none;
            border: none;
            color: #666;
            font-size: 20px;
            cursor: pointer;
            padding: 5px 10px;
            flex-shrink: 0;
        }

        .sub-delete:hover {
            color: #ff4500;
        }

        .sub-delete-bg {
            position: absolute;
            right: 0;
            top: 0;
            bottom: 0;
            background: #d32f2f;
            color: #fff;
            display: flex;
            align-items: center;
            padding: 0 20px;
            font-size: 14px;
            font-weight: 600;
            transform: translateX(100%);
            transition: transform 0.2s;
        }

        /* Feed view */
        .feed-view {
            height: 100%;
            height: 100vh;
            height: -webkit-fill-available;
            display: none;
            flex-direction: column;
            background: #000;
        }

        .feed-view.active {
            display: flex;
        }

        .feed-header {
            position: fixed;
            top: 0;
            left: 0;
            right: 0;
            z-index: 100;
            display: flex;
            align-items: center;
            padding: 12px 16px;
            padding-top: calc(env(safe-area-inset-top) + 12px);
            padding-left: calc(env(safe-area-inset-left) + 16px);
            padding-right: calc(env(safe-area-inset-right) + 16px);
            background: linear-gradient(to bottom, rgba(0,0,0,0.8) 0%, rgba(0,0,0,0) 100%);
            pointer-events: none;
        }

        .feed-header > * {
            pointer-events: auto;
        }

        .back-btn {
            background: rgba(255,255,255,0.15);
            border: none;
            color: #fff;
            width: 40px;
            height: 40px;
            border-radius: 50%;
            font-size: 20px;
            cursor: pointer;
            display: flex;
            align-items: center;
            justify-content: center;
            backdrop-filter: blur(10px);
            -webkit-backdrop-filter: blur(10px);
        }

        .feed-title {
            flex: 1;
            font-size: 17px;
            font-weight: 600;
            text-align: center;
            margin: 0 12px;
            text-shadow: 0 1px 3px rgba(0,0,0,0.5);
        }

        .refresh-btn {
            background: rgba(255,255,255,0.15);
            border: none;
            color: #fff;
            width: 40px;
            height: 40px;
            border-radius: 50%;
            font-size: 18px;
            cursor: pointer;
            display: flex;
            align-items: center;
            justify-content: center;
            backdrop-filter: blur(10px);
            -webkit-backdrop-filter: blur(10px);
        }

        .refresh-btn.spinning {
            animation: spin 1s linear infinite;
        }

        @keyframes spin {
            to { transform: rotate(360deg); }
        }

        /* Feed container with scroll-snap */
        .feed-container {
            flex: 1;
            overflow-y: scroll;
            scroll-snap-type: y mandatory;
            -webkit-overflow-scrolling: touch;
            scrollbar-width: none;
            -ms-overflow-style: none;
        }

        .feed-container::-webkit-scrollbar {
            display: none;
        }

        /* Individual feed item */
        .feed-item {
            height: 100vh;
            height: 100dvh;
            width: 100%;
            scroll-snap-align: start;
            scroll-snap-stop: always;
            position: relative;
            display: flex;
            align-items: center;
            justify-content: center;
            background: #000;
            overflow: hidden;
        }

        .media-container {
            display: flex;
            align-items: center;
            justify-content: center;
            width: 100%;
            height: 100%;
        }

        .feed-item-media {
            max-width: 100%;
            max-height: 100%;
            width: auto;
            height: auto;
            object-fit: contain;
        }

        .feed-item video {
            max-width: 100%;
            max-height: 100%;
            width: 100%;
            height: 100%;
            object-fit: contain;
        }

        .feed-item-overlay {
            position: absolute;
            bottom: 0;
            left: 0;
            right: 0;
            padding: 60px 16px 20px 16px;
            padding-bottom: calc(env(safe-area-inset-bottom) + 20px);
            padding-left: calc(env(safe-area-inset-left) + 16px);
            padding-right: calc(env(safe-area-inset-right) + 16px);
            background: linear-gradient(to top, rgba(0,0,0,0.8) 0%, rgba(0,0,0,0) 100%);
            pointer-events: none;
        }

        .feed-item-title {
            font-size: 15px;
            font-weight: 500;
            line-height: 1.4;
            margin-bottom: 8px;
            text-shadow: 0 1px 3px rgba(0,0,0,0.5);
            display: -webkit-box;
            -webkit-line-clamp: 3;
            -webkit-box-orient: vertical;
            overflow: hidden;
        }

        .feed-item-meta {
            font-size: 13px;
            color: rgba(255,255,255,0.7);
            display: flex;
            gap: 12px;
            flex-wrap: wrap;
        }

        .feed-item-score {
            color: #ff4500;
            font-weight: 600;
        }

        /* Gallery navigation */
        .gallery-nav {
            position: absolute;
            bottom: calc(env(safe-area-inset-bottom) + 155px);
            background: rgba(255,255,255,0.2);
            border: none;
            color: #fff;
            width: 44px;
            height: 44px;
            border-radius: 50%;
            font-size: 20px;
            cursor: pointer;
            display: flex;
            align-items: center;
            justify-content: center;
            backdrop-filter: blur(10px);
            -webkit-backdrop-filter: blur(10px);
            z-index: 10;
        }

        .gallery-nav.prev {
            left: calc(env(safe-area-inset-left) + 12px);
        }

        .gallery-nav.next {
            right: calc(env(safe-area-inset-right) + 12px);
        }

        .gallery-indicator {
            position: absolute;
            bottom: calc(env(safe-area-inset-bottom) + 165px);
            left: 50%;
            transform: translateX(-50%);
            background: rgba(0,0,0,0.6);
            padding: 6px 12px;
            border-radius: 12px;
            font-size: 13px;
            font-weight: 500;
            z-index: 5;
        }

        /* Loading state */
        .feed-loading {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            display: flex;
            flex-direction: column;
            align-items: center;
            gap: 12px;
        }

        .loading-spinner {
            width: 40px;
            height: 40px;
            border: 3px solid #333;
            border-top-color: #ff4500;
            border-radius: 50%;
            animation: spin 1s linear infinite;
        }

        /* Error state */
        .feed-error {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            text-align: center;
            padding: 20px;
        }

        .feed-error p {
            color: #888;
            margin-bottom: 16px;
        }

        .retry-btn {
            background: #2a2a2a;
            border: 1px solid #3a3a3a;
            color: #fff;
            padding: 12px 24px;
            border-radius: 20px;
            font-size: 15px;
            cursor: pointer;
        }

        /* End of feed */
        .feed-end {
            height: 100vh;
            height: 100dvh;
            scroll-snap-align: start;
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            gap: 16px;
            padding: 20px;
        }

        .feed-end p {
            color: #888;
            font-size: 16px;
        }

        .load-more-btn {
            background: #ff4500;
            border: none;
            color: #fff;
            padding: 14px 32px;
            border-radius: 25px;
            font-size: 16px;
            font-weight: 600;
            cursor: pointer;
        }

        .load-more-btn:disabled {
            opacity: 0.6;
        }

        /* Hidden state */
        .hidden {
            display: none !important;
        }

        /* Empty state */
        .empty-state {
            color: #666;
            text-align: center;
            padding: 40px 20px;
        }

        /* Mixed feed item */
        .mixed-feed-item {
            display: flex;
            align-items: center;
            padding: 16px;
            margin-bottom: 16px;
            background: linear-gradient(135deg, #ff4500 0%, #ff6b35 100%);
            border-radius: 12px;
            cursor: pointer;
            transition: transform 0.15s, opacity 0.15s;
        }

        .mixed-feed-item:active {
            transform: scale(0.98);
            opacity: 0.9;
        }

        .mixed-feed-icon {
            font-size: 24px;
            margin-right: 12px;
        }

        .mixed-feed-text {
            flex: 1;
        }

        .mixed-feed-title {
            font-size: 17px;
            font-weight: 600;
            color: #fff;
        }

        .mixed-feed-subtitle {
            font-size: 13px;
            color: rgba(255,255,255,0.8);
            margin-top: 2px;
        }

        .mixed-feed-arrow {
            color: rgba(255,255,255,0.8);
            font-size: 18px;
        }

        /* Video play button overlay */
        .video-play-overlay {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            width: 80px;
            height: 80px;
            background: rgba(0, 0, 0, 0.6);
            border-radius: 50%;
            display: flex;
            align-items: center;
            justify-content: center;
            cursor: pointer;
            opacity: 0;
            transition: opacity 0.2s;
            pointer-events: none;
            z-index: 5;
        }

        .video-play-overlay.visible {
            opacity: 1;
            pointer-events: auto;
        }

        .video-play-overlay::after {
            content: '';
            width: 0;
            height: 0;
            border-style: solid;
            border-width: 15px 0 15px 25px;
            border-color: transparent transparent transparent #fff;
            margin-left: 5px;
        }

        /* Media error state */
        .media-error {
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            gap: 12px;
            color: #666;
        }

        .media-error-icon {
            font-size: 48px;
            opacity: 0.5;
        }

        .skip-btn {
            background: rgba(255,255,255,0.1);
            border: 1px solid #444;
            color: #fff;
            padding: 10px 20px;
            border-radius: 20px;
            font-size: 14px;
            cursor: pointer;
        }

        /* Heart button */
        .heart-btn {
            position: absolute;
            right: calc(env(safe-area-inset-right) + 16px);
            bottom: calc(env(safe-area-inset-bottom) + 100px);
            background: rgba(0, 0, 0, 0.4);
            border: none;
            width: 48px;
            height: 48px;
            border-radius: 50%;
            display: flex;
            align-items: center;
            justify-content: center;
            cursor: pointer;
            backdrop-filter: blur(10px);
            -webkit-backdrop-filter: blur(10px);
            z-index: 10;
            transition: transform 0.15s;
        }

        .heart-btn:active {
            transform: scale(0.9);
        }

        .heart-btn svg {
            width: 26px;
            height: 26px;
            transition: transform 0.2s;
        }

        .heart-btn.hearted svg {
            animation: heartPop 0.3s ease-out;
        }

        @keyframes heartPop {
            0% { transform: scale(1); }
            50% { transform: scale(1.3); }
            100% { transform: scale(1); }
        }

        /* Favorites item on home */
        .favorites-feed-item {
            display: flex;
            align-items: center;
            padding: 16px;
            margin-bottom: 16px;
            background: linear-gradient(135deg, #e91e63 0%, #f06292 100%);
            border-radius: 12px;
            cursor: pointer;
            transition: transform 0.15s, opacity 0.15s;
        }

        .favorites-feed-item:active {
            transform: scale(0.98);
            opacity: 0.9;
        }

        .favorites-feed-item.empty {
            background: linear-gradient(135deg, #424242 0%, #616161 100%);
            cursor: default;
        }

        .favorites-feed-item.empty:active {
            transform: none;
            opacity: 1;
        }

        .hls-toggle {
            background: #2a2a2a;
            border: 1px solid #3a3a3a;
            color: #888;
            padding: 6px 12px;
            border-radius: 8px;
            font-size: 12px;
            font-weight: 600;
            cursor: pointer;
        }

        .hls-toggle.active {
            background: #ff4500;
            border-color: #ff4500;
            color: #fff;
        }
    </style>
</head>
<body>
    <div class="home-view" id="home-view">
        <div class="header">
            <h1>Feed <span class="version">v6</span></h1>
            <button class="hls-toggle" id="hls-toggle">HLS</button>
            <select class="sort-select" id="sort-select">
                <option value="hot">Hot</option>
                <option value="new">New</option>
                <option value="top">Top</option>
                <option value="rising">Rising</option>
            </select>
            <select class="sort-select time-select" id="time-select">
                <option value="day">Today</option>
                <option value="week">This Week</option>
                <option value="month">This Month</option>
                <option value="year">This Year</option>
                <option value="all">All Time</option>
            </select>
        </div>
        <div class="add-row">
            <input type="text" id="sub-input" placeholder="Add subreddit..." autocapitalize="none" autocorrect="off">
            <button id="add-btn">Add</button>
        </div>
        <ul class="sub-list" id="sub-list"></ul>
    </div>

    <div class="feed-view" id="feed-view">
        <div class="feed-header">
            <button class="back-btn" id="back-btn">&larr;</button>
            <span class="feed-title" id="feed-title">r/pics</span>
            <button class="refresh-btn" id="refresh-btn">&#x21bb;</button>
        </div>
        <div class="feed-container" id="feed-container"></div>
    </div>

    <script>
        const PROXY = 'https://little-sunset-822a.maattp.workers.dev/';
        const LS_KEY = 'feed-subs';
        const LS_SORT_KEY = 'feed-sort';
        const LS_TIME_KEY = 'feed-time';
        const FAV_META_KEY = 'fav-meta';
        const FAV_PREFIX = 'fav:';
        const FAV_PAGE_SIZE = 50;
        const DEFAULT_SUBS = ['pics', 'videos', 'gifs', 'aww'];
        const SORT_OPTIONS = ['hot', 'new', 'top', 'rising'];
        const TIME_OPTIONS = [
            { value: 'day', label: 'Today' },
            { value: 'week', label: 'This Week' },
            { value: 'month', label: 'This Month' },
            { value: 'year', label: 'This Year' },
            { value: 'all', label: 'All Time' }
        ];

        let state = {
            view: 'home',
            sub: null,
            isMixed: false,
            isFavorites: false,
            posts: [],
            after: null,
            favCursor: null, // For paginated favorites loading
            currentIndex: 0,
            loading: false,
            sort: localStorage.getItem(LS_SORT_KEY) || 'hot',
            timePeriod: localStorage.getItem(LS_TIME_KEY) || 'day',
            mixedQueue: [] // Shuffled queue of subreddits for mixed feed
        };

        // Windowed rendering settings - controls media loading, not DOM presence
        const WINDOW_BEFORE = 3;  // Items to preload before current
        const WINDOW_AFTER = 4;   // Items to preload after current

        // Single observer instance to avoid memory leaks
        let feedObserver = null;

        // Track which items have media loaded
        let loadedMediaItems = new Set();

        // Track if user has enabled audio (persists during session)
        let audioEnabled = false;

        // Track if HLS mode is enabled (for testing)
        let useHls = false;

        // Fisher-Yates shuffle - ensures even distribution
        function shuffleArray(array) {
            const shuffled = [...array];
            for (let i = shuffled.length - 1; i > 0; i--) {
                const j = Math.floor(Math.random() * (i + 1));
                [shuffled[i], shuffled[j]] = [shuffled[j], shuffled[i]];
            }
            return shuffled;
        }

        // Get next subreddit from shuffled queue, reshuffling when empty
        function getNextMixedSubreddit() {
            const subs = getSubs();
            if (subs.length === 0) return null;

            // Refill and shuffle queue if empty
            if (state.mixedQueue.length === 0) {
                state.mixedQueue = shuffleArray(subs);
            }

            return state.mixedQueue.shift();
        }

        function getSubs() {
            try {
                const stored = localStorage.getItem(LS_KEY);
                if (stored) {
                    const parsed = JSON.parse(stored);
                    if (Array.isArray(parsed)) return parsed;
                }
            } catch (e) {
                // Corrupted localStorage, reset to defaults
            }
            localStorage.setItem(LS_KEY, JSON.stringify(DEFAULT_SUBS));
            return [...DEFAULT_SUBS];
        }

        function saveSubs(subs) {
            try {
                localStorage.setItem(LS_KEY, JSON.stringify(subs));
            } catch (e) {
                // localStorage full or unavailable
            }
        }

        // Favorites management - doubly linked list in localStorage
        // Each favorite stored as separate key: fav:{id} -> {data, prev, next}
        // Metadata stored as: fav-meta -> {head, tail, count}

        function getFavMeta() {
            try {
                const stored = localStorage.getItem(FAV_META_KEY);
                if (stored) return JSON.parse(stored);
            } catch (e) {}
            return { head: null, tail: null, count: 0 };
        }

        function saveFavMeta(meta) {
            localStorage.setItem(FAV_META_KEY, JSON.stringify(meta));
        }

        function getFavoriteById(id) {
            try {
                const stored = localStorage.getItem(FAV_PREFIX + id);
                if (stored) return JSON.parse(stored);
            } catch (e) {}
            return null;
        }

        function saveFavoriteNode(fav) {
            localStorage.setItem(FAV_PREFIX + fav.id, JSON.stringify(fav));
        }

        function deleteFavoriteNode(id) {
            localStorage.removeItem(FAV_PREFIX + id);
        }

        // O(1) check - just see if key exists
        function isFavorited(postId) {
            return localStorage.getItem(FAV_PREFIX + postId) !== null;
        }

        // Get favorites count from metadata - O(1)
        function getFavoritesCount() {
            return getFavMeta().count;
        }

        // Load favorites with pagination - O(n) but only for requested page
        function loadFavorites(startFromId = null, limit = FAV_PAGE_SIZE) {
            const meta = getFavMeta();
            const favorites = [];
            let currentId = startFromId || meta.head;
            let count = 0;

            while (currentId && count < limit) {
                const fav = getFavoriteById(currentId);
                if (!fav) {
                    // Corrupted list - treat as end to prevent infinite loop
                    currentId = null;
                    break;
                }
                favorites.push(fav);
                currentId = fav.next;
                count++;
            }

            return {
                favorites,
                nextCursor: currentId,
                hasMore: currentId !== null
            };
        }

        // Extract minimal data from post for persistence
        function extractFavoriteData(post) {
            return {
                id: post.id,
                title: post.title,
                subreddit: post.subreddit,
                author: post.author,
                score: post.score,
                created_utc: post.created_utc,
                num_comments: post.num_comments,
                thumbnail: post.thumbnail,
                media: post.media,
                hearted_at: Date.now()
            };
        }

        // Add favorite - O(1), returns false if storage full
        function addFavorite(post) {
            const meta = getFavMeta();

            // Update old head's prev pointer (if it exists and is valid)
            let validNext = null;
            if (meta.head) {
                const oldHead = getFavoriteById(meta.head);
                if (oldHead) {
                    oldHead.prev = post.id;
                    try {
                        saveFavoriteNode(oldHead);
                    } catch (e) {
                        if (e.name === 'QuotaExceededError') return false;
                        throw e;
                    }
                    validNext = meta.head;
                }
            }

            const fav = {
                ...extractFavoriteData(post),
                prev: null,
                next: validNext
            };

            // Save new favorite
            try {
                saveFavoriteNode(fav);
            } catch (e) {
                if (e.name === 'QuotaExceededError') {
                    // Rollback: restore old head's prev pointer
                    if (validNext) {
                        const oldHead = getFavoriteById(validNext);
                        if (oldHead) {
                            oldHead.prev = null;
                            try { saveFavoriteNode(oldHead); } catch (_) {}
                        }
                    }
                    return false;
                }
                throw e;
            }

            // Update metadata
            meta.head = fav.id;
            if (!meta.tail || !validNext) meta.tail = fav.id;
            meta.count++;
            try {
                saveFavMeta(meta);
            } catch (e) {
                // Rollback: delete the node we just added
                deleteFavoriteNode(fav.id);
                if (validNext) {
                    const oldHead = getFavoriteById(validNext);
                    if (oldHead) {
                        oldHead.prev = null;
                        try { saveFavoriteNode(oldHead); } catch (_) {}
                    }
                }
                if (e.name === 'QuotaExceededError') return false;
                throw e;
            }
            return true;
        }

        // Remove favorite - O(1)
        function removeFavorite(id) {
            const fav = getFavoriteById(id);
            if (!fav) return;

            const meta = getFavMeta();

            // Update prev node's next pointer
            if (fav.prev) {
                const prevNode = getFavoriteById(fav.prev);
                if (prevNode) {
                    prevNode.next = fav.next;
                    saveFavoriteNode(prevNode);
                }
            } else {
                // Was head
                meta.head = fav.next;
            }

            // Update next node's prev pointer
            if (fav.next) {
                const nextNode = getFavoriteById(fav.next);
                if (nextNode) {
                    nextNode.prev = fav.prev;
                    saveFavoriteNode(nextNode);
                }
            } else {
                // Was tail
                meta.tail = fav.prev;
            }

            // Delete the node
            deleteFavoriteNode(id);

            // Update metadata
            meta.count--;
            saveFavMeta(meta);
        }

        // Toggle favorite - returns {hearted: bool, error: string|null}
        function toggleFavorite(post) {
            if (isFavorited(post.id)) {
                removeFavorite(post.id);
                return { hearted: false, error: null };
            } else {
                const success = addFavorite(post);
                if (!success) {
                    return { hearted: false, error: 'Storage full. Remove some favorites first.' };
                }
                return { hearted: true, error: null };
            }
        }

        async function redditFetch(path, retries = 3) {
            const url = `${PROXY}?url=${encodeURIComponent('https://www.reddit.com' + path)}`;
            let lastError;
            for (let attempt = 0; attempt < retries; attempt++) {
                try {
                    if (attempt > 0) {
                        await new Promise(r => setTimeout(r, 1000 * Math.pow(2, attempt - 1)));
                    }
                    const res = await fetch(url);
                    if (res.status === 429) {
                        const err = new Error('Rate limited');
                        err.status = 429;
                        throw err;
                    }
                    if (!res.ok) throw new Error(res.status);
                    return res.json();
                } catch (err) {
                    lastError = err;
                    if (err.status === 429) break; // Don't retry rate limits
                }
            }
            throw lastError;
        }

        function timeAgo(utc) {
            const seconds = Math.floor(Date.now() / 1000 - utc);
            if (seconds < 0) return 'just now'; // Handle future timestamps (clock skew)
            if (seconds < 60) return 'just now';
            if (seconds < 3600) return Math.floor(seconds / 60) + 'm';
            if (seconds < 86400) return Math.floor(seconds / 3600) + 'h';
            if (seconds < 604800) return Math.floor(seconds / 86400) + 'd';
            return Math.floor(seconds / 604800) + 'w';
        }

        function formatScore(n) {
            if (n >= 100000) return (n / 1000).toFixed(0) + 'k';
            if (n >= 10000) return (n / 1000).toFixed(1) + 'k';
            if (n >= 1000) return (n / 1000).toFixed(1) + 'k';
            return String(n);
        }

        function escapeHtml(s) {
            const d = document.createElement('div');
            d.textContent = s;
            return d.innerHTML;
        }

        // Extract media info from a Reddit post
        function extractMedia(post) {
            const media = {
                type: null,
                url: null,
                urls: null,  // For galleries
                thumbnail: null,
                width: 0,
                height: 0
            };

            // Reddit hosted video (check both media and secure_media)
            const redditVideo = post.media?.reddit_video || post.secure_media?.reddit_video;
            if (post.is_video && redditVideo) {
                media.type = 'video';
                media.url = useHls && redditVideo.hls_url ? redditVideo.hls_url : redditVideo.fallback_url;
                media.width = redditVideo.width;
                media.height = redditVideo.height;
                return media;
            }

            // Cross-post with video
            if (post.crosspost_parent_list?.length > 0) {
                const parent = post.crosspost_parent_list[0];
                const parentVideo = parent.media?.reddit_video || parent.secure_media?.reddit_video;
                if (parent.is_video && parentVideo) {
                    media.type = 'video';
                    media.url = useHls && parentVideo.hls_url ? parentVideo.hls_url : parentVideo.fallback_url;
                    media.width = parentVideo.width;
                    media.height = parentVideo.height;
                    return media;
                }
            }

            // Gallery posts
            if (post.is_gallery && post.gallery_data?.items && post.media_metadata) {
                const items = post.gallery_data.items;
                const urls = [];
                for (const item of items) {
                    const meta = post.media_metadata[item.media_id];
                    if (meta && meta.s && meta.status !== 'failed') {
                        // Get the highest quality image
                        let imgUrl = meta.s.u || meta.s.gif;
                        if (imgUrl) {
                            // Decode HTML entities in URL
                            imgUrl = imgUrl.replace(/&amp;/g, '&');
                            urls.push({
                                url: imgUrl,
                                width: meta.s.x,
                                height: meta.s.y
                            });
                        }
                    }
                }
                if (urls.length > 0) {
                    media.type = 'gallery';
                    media.urls = urls;
                    media.url = urls[0].url;
                    media.width = urls[0].width;
                    media.height = urls[0].height;
                    return media;
                }
            }

            // GIF from preview (reddit serves as mp4)
            if (post.preview?.reddit_video_preview) {
                media.type = 'video';
                media.url = post.preview.reddit_video_preview.fallback_url;
                media.width = post.preview.reddit_video_preview.width;
                media.height = post.preview.reddit_video_preview.height;
                return media;
            }

            // Check for mp4 variant in preview images
            if (post.preview?.images?.[0]?.variants?.mp4) {
                const mp4 = post.preview.images[0].variants.mp4.source;
                media.type = 'video';
                media.url = mp4.url.replace(/&amp;/g, '&');
                media.width = mp4.width;
                media.height = mp4.height;
                return media;
            }

            // Check for gif variant in preview images
            if (post.preview?.images?.[0]?.variants?.gif) {
                const gif = post.preview.images[0].variants.gif.source;
                media.type = 'image';
                media.url = gif.url.replace(/&amp;/g, '&');
                media.width = gif.width;
                media.height = gif.height;
                return media;
            }

            // Regular image post
            if (post.post_hint === 'image' ||
                /\.(jpg|jpeg|png|gif|webp)(\?.*)?$/i.test(post.url)) {
                media.type = 'image';
                media.url = post.url.replace(/&amp;/g, '&');
                if (post.preview?.images?.[0]?.source) {
                    media.width = post.preview.images[0].source.width;
                    media.height = post.preview.images[0].source.height;
                }
                return media;
            }

            // External video hosts (YouTube, etc.) - skip, can't autoplay
            if (post.post_hint === 'rich:video') {
                return null;
            }

            // Fallback to preview image if available
            if (post.preview?.images?.[0]?.source) {
                const src = post.preview.images[0].source;
                media.type = 'image';
                media.url = src.url.replace(/&amp;/g, '&');
                media.width = src.width;
                media.height = src.height;
                return media;
            }

            return null;
        }

        // Calculate the window range for media loading around current index
        function getMediaWindow(currentIndex) {
            const start = Math.max(0, currentIndex - WINDOW_BEFORE);
            const end = Math.min(state.posts.length - 1, currentIndex + WINDOW_AFTER);
            return { start, end };
        }

        // Skip to next feed item
        function skipToNext(currentIndex) {
            const container = document.getElementById('feed-container');
            const nextItem = container.querySelector(`.feed-item[data-index="${currentIndex + 1}"]`);
            if (nextItem) {
                nextItem.scrollIntoView({ behavior: 'smooth' });
            }
        }

        // Handle media error - show error state with skip button
        function handleMediaError(feedItem, index) {
            const mediaEl = feedItem.querySelector('.feed-item-media');
            if (mediaEl) {
                mediaEl.style.display = 'none';
            }

            // Check if error state already exists
            if (feedItem.querySelector('.media-error')) return;

            const errorDiv = document.createElement('div');
            errorDiv.className = 'media-error';
            errorDiv.innerHTML = `
                <div class="media-error-icon">‚ö†Ô∏è</div>
                <p>Failed to load media</p>
                <button class="skip-btn" data-action="skip" data-index="${index}">Skip to Next</button>
            `;
            feedItem.insertBefore(errorDiv, feedItem.querySelector('.feed-item-overlay'));

            // Auto-skip after 2 seconds
            setTimeout(() => {
                if (state.currentIndex === index) {
                    skipToNext(index);
                }
            }, 2000);
        }

        // Render home view
        function renderHome() {
            const subs = getSubs();
            const list = document.getElementById('sub-list');

            // Set sort select to current value
            const sortSelect = document.getElementById('sort-select');
            sortSelect.value = state.sort;

            // Set time select to current value and show/hide based on sort
            const timeSelect = document.getElementById('time-select');
            timeSelect.value = state.timePeriod;
            timeSelect.classList.toggle('visible', state.sort === 'top');

            // Build mixed feed item if we have subreddits
            const mixedHtml = subs.length > 0 ? `
                <div class="mixed-feed-item" id="mixed-feed-btn">
                    <span class="mixed-feed-icon">üîÄ</span>
                    <div class="mixed-feed-text">
                        <div class="mixed-feed-title">Mixed Feed</div>
                        <div class="mixed-feed-subtitle">Posts from all your subreddits</div>
                    </div>
                    <span class="mixed-feed-arrow">&rsaquo;</span>
                </div>
            ` : '';

            // Build favorites item
            const favCount = getFavoritesCount();
            const favoritesHtml = favCount > 0 ? `
                <div class="favorites-feed-item" id="favorites-feed-btn">
                    <span class="mixed-feed-icon">‚ù§Ô∏è</span>
                    <div class="mixed-feed-text">
                        <div class="mixed-feed-title">Favorites</div>
                        <div class="mixed-feed-subtitle">${favCount} saved post${favCount !== 1 ? 's' : ''}</div>
                    </div>
                    <span class="mixed-feed-arrow">&rsaquo;</span>
                </div>
            ` : `
                <div class="favorites-feed-item empty">
                    <span class="mixed-feed-icon">ü§ç</span>
                    <div class="mixed-feed-text">
                        <div class="mixed-feed-title">Favorites</div>
                        <div class="mixed-feed-subtitle">Heart posts to save them here</div>
                    </div>
                </div>
            `;

            if (subs.length === 0) {
                list.innerHTML = favoritesHtml + '<li class="empty-state">No subreddits yet. Add one above.</li>';
            } else {
                list.innerHTML = mixedHtml + favoritesHtml + subs.map(s => `
                    <li class="sub-item" data-sub="${escapeHtml(s)}">
                        <div class="sub-delete-bg">Delete</div>
                        <div class="sub-item-content">
                            <span class="sub-name">r/${escapeHtml(s)}</span>
                            <span class="sub-arrow">&rsaquo;</span>
                        </div>
                        <button class="sub-delete" title="Delete">&times;</button>
                    </li>
                `).join('');
            }

            bindHomeEvents();

            document.getElementById('home-view').classList.remove('hidden');
            document.getElementById('feed-view').classList.remove('active');
            state.view = 'home';
            history.replaceState({ view: 'home' }, '', '/apps/feed/');
        }

        function bindHomeEvents() {
            const input = document.getElementById('sub-input');
            const addBtn = document.getElementById('add-btn');

            // Remove old listeners by cloning
            const newInput = input.cloneNode(true);
            const newAddBtn = addBtn.cloneNode(true);
            input.parentNode.replaceChild(newInput, input);
            addBtn.parentNode.replaceChild(newAddBtn, addBtn);

            function addSub() {
                const val = newInput.value.trim().replace(/^r\//, '').replace(/\//g, '').toLowerCase();
                if (!val) return;
                const subs = getSubs();
                if (subs.includes(val)) {
                    newInput.value = '';
                    return;
                }
                subs.push(val);
                saveSubs(subs);
                newInput.value = '';
                renderHome();
            }

            newAddBtn.addEventListener('click', addSub);
            newInput.addEventListener('keydown', e => {
                if (e.key === 'Enter') addSub();
            });

            // Mixed feed button
            const mixedBtn = document.getElementById('mixed-feed-btn');
            if (mixedBtn) {
                mixedBtn.addEventListener('click', openMixedFeed);
            }

            // Favorites feed button
            const favoritesBtn = document.getElementById('favorites-feed-btn');
            if (favoritesBtn) {
                favoritesBtn.addEventListener('click', openFavoritesFeed);
            }

            // Delete buttons
            document.querySelectorAll('.sub-delete').forEach(btn => {
                btn.addEventListener('click', e => {
                    e.stopPropagation();
                    const sub = btn.closest('.sub-item').dataset.sub;
                    const subs = getSubs().filter(s => s !== sub);
                    saveSubs(subs);
                    renderHome();
                });
            });

            // Tap to navigate
            document.querySelectorAll('.sub-item-content').forEach(el => {
                el.addEventListener('click', () => {
                    const sub = el.closest('.sub-item').dataset.sub;
                    openFeed(sub);
                });
            });

            // Swipe to delete
            document.querySelectorAll('.sub-item').forEach(item => {
                let startX = 0;
                let currentX = 0;
                let swiping = false;

                item.addEventListener('touchstart', e => {
                    startX = e.touches[0].clientX;
                    currentX = startX;
                    swiping = true;
                }, { passive: true });

                item.addEventListener('touchmove', e => {
                    if (!swiping) return;
                    currentX = e.touches[0].clientX;
                    const diff = startX - currentX;
                    if (diff > 0) {
                        const translate = Math.min(diff, 80);
                        item.querySelector('.sub-item-content').style.transform = `translateX(-${translate}px)`;
                        item.querySelector('.sub-delete-bg').style.transform = `translateX(${Math.max(0, 80 - diff)}px)`;
                    }
                }, { passive: true });

                item.addEventListener('touchend', () => {
                    if (!swiping) return;
                    swiping = false;
                    const diff = startX - currentX;
                    const content = item.querySelector('.sub-item-content');
                    const bg = item.querySelector('.sub-delete-bg');

                    if (diff > 60) {
                        content.style.transform = 'translateX(-80px)';
                        bg.style.transform = 'translateX(0)';
                        bg.addEventListener('click', () => {
                            const sub = item.dataset.sub;
                            const subs = getSubs().filter(s => s !== sub);
                            saveSubs(subs);
                            renderHome();
                        }, { once: true });
                    } else {
                        content.style.transform = '';
                        bg.style.transform = '';
                    }
                });
            });
        }

        // Common setup for feed view
        function setupFeedView(title, historyPath, historyState) {
            state.posts = [];
            state.after = null;
            state.currentIndex = 0;
            cleanupObserver();

            document.getElementById('home-view').classList.add('hidden');
            document.getElementById('feed-view').classList.add('active');
            document.getElementById('feed-title').textContent = title;
            state.view = 'feed';
            history.pushState(historyState, '', historyPath);

            const container = document.getElementById('feed-container');
            container.innerHTML = `
                <div class="feed-item">
                    <div class="feed-loading">
                        <div class="loading-spinner"></div>
                        <p>Loading...</p>
                    </div>
                </div>
            `;
        }

        // Open feed for subreddit
        async function openFeed(sub) {
            state.sub = sub;
            state.isMixed = false;
            state.isFavorites = false;
            setupFeedView(`r/${sub}`, `/apps/feed/#r/${sub}`, { view: 'feed', sub });

            try {
                await loadPosts();
                renderFeed();
            } catch (err) {
                const msg = err.status === 429
                    ? 'Rate limited by Reddit. Wait a minute and try again.'
                    : 'Failed to load posts';
                showFeedError(msg, () => openFeed(sub));
            }
        }

        // Open mixed feed from all subreddits
        async function openMixedFeed() {
            state.sub = null;
            state.isMixed = true;
            state.isFavorites = false;
            state.mixedQueue = []; // Reset queue for fresh shuffle
            setupFeedView('Mixed Feed', '/apps/feed/#mixed', { view: 'feed', mixed: true });

            try {
                await loadMixedPosts();
                renderFeed();
            } catch (err) {
                const msg = err.status === 429
                    ? 'Rate limited by Reddit. Wait a minute and try again.'
                    : 'Failed to load posts';
                showFeedError(msg, () => openMixedFeed());
            }
        }

        // Open favorites feed
        function openFavoritesFeed() {
            if (getFavoritesCount() === 0) return;

            state.sub = null;
            state.isMixed = false;
            state.isFavorites = true;
            state.favCursor = null;
            setupFeedView('Favorites', '/apps/feed/#favorites', { view: 'feed', favorites: true });

            // Load first page of favorites
            const { favorites, nextCursor, hasMore } = loadFavorites(null, FAV_PAGE_SIZE);
            state.posts = favorites;
            state.favCursor = nextCursor;
            state.after = hasMore ? 'more' : null; // Use 'after' to signal more available
            renderFeed();
        }

        // Load more favorites (called when scrolling near end)
        function loadMoreFavorites() {
            if (!state.favCursor || state.loading) return;
            state.loading = true;

            try {
                const { favorites, nextCursor, hasMore } = loadFavorites(state.favCursor, FAV_PAGE_SIZE);
                state.posts = state.posts.concat(favorites);
                state.favCursor = nextCursor;
                state.after = hasMore ? 'more' : null;
            } finally {
                state.loading = false;
            }
        }

        function showFeedError(message, retryFn) {
            const container = document.getElementById('feed-container');
            container.innerHTML = `
                <div class="feed-item">
                    <div class="feed-error">
                        <p>${escapeHtml(message)}</p>
                        <button class="retry-btn" id="error-retry-btn">Try Again</button>
                    </div>
                </div>
            `;
            document.getElementById('error-retry-btn').addEventListener('click', retryFn);
        }

        // Fetch posts from a single subreddit
        async function fetchSubredditPosts(subreddit, limit = 50, after = null) {
            let path = `/r/${encodeURIComponent(subreddit)}/${state.sort}.json?limit=${limit}&raw_json=1`;
            if (state.sort === 'top') path += `&t=${state.timePeriod}`;
            if (after) path += `&after=${after}`;

            const data = await redditFetch(path);
            const posts = data.data.children
                .map(c => c.data)
                .map(post => {
                    post.media = extractMedia(post);
                    post.subreddit_display = post.subreddit; // Keep track of source
                    return post;
                })
                .filter(post => post.media !== null);

            return { posts, after: data.data.after };
        }

        // Load posts for mixed feed from shuffled subreddit queue
        async function loadMixedPosts() {
            if (state.loading) return;
            state.loading = true;

            try {
                const nextSub = getNextMixedSubreddit();
                if (!nextSub) return;

                const { posts, after } = await fetchSubredditPosts(nextSub, 15);
                state.posts = state.posts.concat(posts);
                // Always allow loading more (from another sub in queue)
                state.after = getSubs().length > 0 ? 'mixed' : null;
            } finally {
                state.loading = false;
            }
        }

        // Load posts for a single subreddit
        async function loadPosts() {
            if (state.loading) return;
            state.loading = true;

            try {
                const { posts, after } = await fetchSubredditPosts(state.sub, 50, state.after);
                state.posts = state.posts.concat(posts);
                state.after = after;
            } finally {
                state.loading = false;
            }
        }

        function cleanupObserver() {
            if (feedObserver) {
                feedObserver.disconnect();
                feedObserver = null;
            }
        }

        function renderFeed() {
            const container = document.getElementById('feed-container');
            cleanupObserver();
            loadedMediaItems.clear();

            if (state.posts.length === 0) {
                container.innerHTML = `
                    <div class="feed-item">
                        <div class="feed-error">
                            <p>No media posts found</p>
                            <button class="retry-btn" id="go-back-btn">Go Back</button>
                        </div>
                    </div>
                `;
                document.getElementById('go-back-btn').addEventListener('click', goHome);
                return;
            }

            // Render all items at once - media loading is controlled separately
            let html = '';
            for (let i = 0; i < state.posts.length; i++) {
                html += renderFeedItem(state.posts[i], i);
            }

            // Add end of feed indicator if no more posts
            if (!state.after) {
                html += `
                    <div class="feed-end" id="feed-end">
                        <p>That's all for now!</p>
                    </div>
                `;
            }

            container.innerHTML = html;

            // Bind media error handlers
            bindMediaErrorHandlers();

            // Load media for initial window
            const { start, end } = getMediaWindow(state.currentIndex);
            for (let i = start; i <= end; i++) {
                loadMediaForItem(i);
            }

            // Set up scroll observer for video control and media loading
            setupScrollObserver();
        }

        // Load media for a specific item
        function loadMediaForItem(index) {
            if (loadedMediaItems.has(index)) return;

            const container = document.getElementById('feed-container');
            const feedItem = container.querySelector(`.feed-item[data-index="${index}"]`);
            if (!feedItem) return;

            const post = state.posts[index];
            if (!post || !post.media) return;

            const mediaContainer = feedItem.querySelector('.media-container');
            if (!mediaContainer) return;

            const media = post.media;
            let mediaHtml = '';

            if (media.type === 'video') {
                mediaHtml = `
                    <video class="feed-item-media"
                           src="${escapeHtml(media.url)}"
                           autoplay
                           loop
                           muted
                           playsinline
                           preload="auto"
                           webkit-playsinline
                           poster="${post.thumbnail && post.thumbnail !== 'default' ? escapeHtml(post.thumbnail) : ''}">
                    </video>
                    <div class="video-play-overlay"></div>
                `;
            } else if (media.type === 'gallery') {
                mediaHtml = `
                    <img class="feed-item-media gallery-image"
                         data-gallery-index="0"
                         src="${escapeHtml(media.urls[0].url)}"
                         alt="${escapeHtml(post.title)}">
                `;
            } else {
                mediaHtml = `
                    <img class="feed-item-media"
                         src="${escapeHtml(media.url)}"
                         alt="${escapeHtml(post.title)}">
                `;
            }

            mediaContainer.innerHTML = mediaHtml;
            loadedMediaItems.add(index);

            // Bind error handlers for this item
            bindMediaErrorHandlersForItem(feedItem, index);
        }

        // Unload media for a specific item (for videos to save resources)
        function unloadMediaForItem(index) {
            if (!loadedMediaItems.has(index)) return;

            const container = document.getElementById('feed-container');
            const feedItem = container.querySelector(`.feed-item[data-index="${index}"]`);
            if (!feedItem) return;

            const video = feedItem.querySelector('video');
            if (video) {
                video.pause();
                video.removeAttribute('src');
                video.load();

                // Replace with placeholder
                const mediaContainer = feedItem.querySelector('.media-container');
                if (mediaContainer) {
                    const post = state.posts[index];
                    mediaContainer.innerHTML = `<div class="loading-spinner"></div>`;
                }
                loadedMediaItems.delete(index);
            }
            // Keep images loaded - they're cached and lightweight
        }

        // Update media window around current index
        function updateMediaWindow(currentIndex) {
            const { start, end } = getMediaWindow(currentIndex);

            // Load media for items entering window
            for (let i = start; i <= end; i++) {
                loadMediaForItem(i);
            }

            // Unload videos outside window (keep some buffer)
            const unloadBuffer = 2;
            loadedMediaItems.forEach(idx => {
                if (idx < start - unloadBuffer || idx > end + unloadBuffer) {
                    unloadMediaForItem(idx);
                }
            });
        }

        function renderFeedItem(post, index) {
            const media = post.media;
            let galleryNav = '';

            // Gallery navigation is always rendered (if applicable) since DOM is stable
            if (media.type === 'gallery' && media.urls.length > 1) {
                galleryNav = `
                    <button class="gallery-nav prev" data-index="${index}" style="display:none">&lsaquo;</button>
                    <button class="gallery-nav next" data-index="${index}">&rsaquo;</button>
                    <div class="gallery-indicator" data-index="${index}">1 / ${media.urls.length}</div>
                `;
            }

            const subredditMeta = (state.isMixed || state.isFavorites) ? `<span>r/${escapeHtml(post.subreddit)}</span>` : '';
            const isHearted = isFavorited(post.id);

            // Heart SVG icons
            const heartEmpty = `<svg viewBox="0 0 24 24" fill="none" stroke="white" stroke-width="2"><path d="M20.84 4.61a5.5 5.5 0 0 0-7.78 0L12 5.67l-1.06-1.06a5.5 5.5 0 0 0-7.78 7.78l1.06 1.06L12 21.23l7.78-7.78 1.06-1.06a5.5 5.5 0 0 0 0-7.78z"></path></svg>`;
            const heartFilled = `<svg viewBox="0 0 24 24" fill="#ff4081" stroke="#ff4081" stroke-width="2"><path d="M20.84 4.61a5.5 5.5 0 0 0-7.78 0L12 5.67l-1.06-1.06a5.5 5.5 0 0 0-7.78 7.78l1.06 1.06L12 21.23l7.78-7.78 1.06-1.06a5.5 5.5 0 0 0 0-7.78z"></path></svg>`;

            // Media container starts with a loading spinner - actual media loaded on demand
            return `
                <div class="feed-item" data-index="${index}" data-post-id="${post.id}">
                    <div class="media-container">
                        <div class="loading-spinner"></div>
                    </div>
                    ${galleryNav}
                    <button class="heart-btn${isHearted ? ' hearted' : ''}" data-index="${index}" data-post-id="${post.id}">
                        ${isHearted ? heartFilled : heartEmpty}
                    </button>
                    <div class="feed-item-overlay">
                        <div class="feed-item-title">${escapeHtml(post.title)}</div>
                        <div class="feed-item-meta">
                            ${subredditMeta}
                            <span class="feed-item-score">${formatScore(post.score)} pts</span>
                            <span>u/${escapeHtml(post.author)}</span>
                            <span>${timeAgo(post.created_utc)}</span>
                            <span>${post.num_comments} comments</span>
                        </div>
                    </div>
                </div>
            `;
        }

        // Bind error handlers to all media elements (called on initial render)
        function bindMediaErrorHandlers() {
            // No-op on initial render since media isn't loaded yet
            // Individual items get handlers bound when media loads via bindMediaErrorHandlersForItem
        }

        // Bind error handlers for a specific item after its media loads
        function bindMediaErrorHandlersForItem(feedItem, index) {
            const img = feedItem.querySelector('img.feed-item-media');
            if (img) {
                img.onerror = function() {
                    handleMediaError(feedItem, index);
                };
            }

            const video = feedItem.querySelector('video');
            if (video) {
                video.onerror = function() {
                    handleMediaError(feedItem, index);
                };

                // Show/hide play button based on video state
                const playOverlay = feedItem.querySelector('.video-play-overlay');
                if (playOverlay) {
                    video.addEventListener('pause', () => {
                        if (state.currentIndex === index) {
                            playOverlay.classList.add('visible');
                        }
                    });

                    video.addEventListener('play', () => {
                        playOverlay.classList.remove('visible');
                    });

                    // Initially check if video is paused after a short delay
                    setTimeout(() => {
                        if (video.paused && state.currentIndex === index) {
                            playOverlay.classList.add('visible');
                        }
                    }, 500);
                }
            }
        }

        function setupScrollObserver() {
            const container = document.getElementById('feed-container');
            const items = container.querySelectorAll('.feed-item[data-index]');

            feedObserver = new IntersectionObserver((entries) => {
                entries.forEach(entry => {
                    const item = entry.target;
                    const index = parseInt(item.dataset.index);

                    if (entry.isIntersecting && entry.intersectionRatio > 0.5) {
                        state.currentIndex = index;

                        // Update media loading window
                        updateMediaWindow(index);

                        // Play video if visible
                        const video = item.querySelector('video');
                        if (video) {
                            // If user has enabled audio, try to unmute
                            if (audioEnabled) {
                                video.muted = false;
                            }
                            const playPromise = video.play();
                            if (playPromise !== undefined) {
                                playPromise.catch(err => {
                                    // If unmuted play fails, try muted (iOS restriction)
                                    if (!video.muted) {
                                        video.muted = true;
                                        video.play().catch(() => {});
                                    } else if (video.readyState < 2) {
                                        video.addEventListener('canplay', () => {
                                            video.play().catch(() => {});
                                        }, { once: true });
                                    }
                                });
                            }
                        }

                        // Auto-load more when near end of available posts
                        if (index >= state.posts.length - 5 && state.after && !state.loading) {
                            if (state.isFavorites) {
                                loadMoreFavorites();
                                appendNewItems();
                            } else {
                                const loadFn = state.isMixed ? loadMixedPosts : loadPosts;
                                loadFn().then(() => {
                                    appendNewItems();
                                }).catch(() => {});
                            }
                        }
                    } else {
                        // Pause video when not visible
                        const video = item.querySelector('video');
                        if (video) {
                            video.pause();
                            // Hide play overlay when scrolling away
                            const playOverlay = item.querySelector('.video-play-overlay');
                            if (playOverlay) {
                                playOverlay.classList.remove('visible');
                            }
                        }
                    }
                });
            }, {
                threshold: [0, 0.5, 1]
            });

            items.forEach(item => feedObserver.observe(item));
        }

        // Append newly loaded posts to the feed
        function appendNewItems() {
            const container = document.getElementById('feed-container');
            const existingCount = container.querySelectorAll('.feed-item[data-index]').length;

            if (existingCount >= state.posts.length) return;

            // Remove end-of-feed indicator if present
            const feedEnd = container.querySelector('.feed-end');
            if (feedEnd) feedEnd.remove();

            // Append new items
            let html = '';
            for (let i = existingCount; i < state.posts.length; i++) {
                html += renderFeedItem(state.posts[i], i);
            }

            // Add end of feed indicator if no more posts
            if (!state.after) {
                html += `
                    <div class="feed-end" id="feed-end">
                        <p>That's all for now!</p>
                    </div>
                `;
            }

            container.insertAdjacentHTML('beforeend', html);

            // Observe new items
            const newItems = container.querySelectorAll('.feed-item[data-index]');
            newItems.forEach(item => {
                const idx = parseInt(item.dataset.index);
                if (idx >= existingCount && feedObserver) {
                    feedObserver.observe(item);
                }
            });

            // Load media for items in current window
            updateMediaWindow(state.currentIndex);
        }

        function goHome() {
            // Stop all videos and release resources
            document.querySelectorAll('video').forEach(v => {
                v.pause();
                v.removeAttribute('src');
                v.load();
            });

            cleanupObserver();
            loadedMediaItems.clear();
            renderHome();
        }

        // Event listeners
        document.getElementById('back-btn').addEventListener('click', goHome);

        // Sort select listener
        document.getElementById('sort-select').addEventListener('change', function() {
            state.sort = this.value;
            localStorage.setItem(LS_SORT_KEY, state.sort);
            // Show/hide time select based on sort type
            const timeSelect = document.getElementById('time-select');
            timeSelect.classList.toggle('visible', state.sort === 'top');
        });

        // Time period select listener
        document.getElementById('time-select').addEventListener('change', function() {
            state.timePeriod = this.value;
            localStorage.setItem(LS_TIME_KEY, state.timePeriod);
        });

        document.getElementById('refresh-btn').addEventListener('click', async function() {
            if (state.loading) return;
            this.classList.add('spinning');
            state.posts = [];
            state.after = null;
            state.currentIndex = 0;
            cleanupObserver();
            loadedMediaItems.clear();

            try {
                if (state.isFavorites) {
                    // Reload from storage
                    if (getFavoritesCount() === 0) {
                        goHome();
                        return;
                    }
                    const { favorites, nextCursor, hasMore } = loadFavorites(null, FAV_PAGE_SIZE);
                    state.posts = favorites;
                    state.favCursor = nextCursor;
                    state.after = hasMore ? 'more' : null;
                } else {
                    const loadFn = state.isMixed ? loadMixedPosts : loadPosts;
                    await loadFn();
                }
                renderFeed();
                document.getElementById('feed-container').scrollTop = 0;
            } catch (err) {
                const msg = err.status === 429
                    ? 'Rate limited by Reddit. Wait a minute and try again.'
                    : 'Failed to refresh';
                const retryFn = state.isMixed ? openMixedFeed : () => openFeed(state.sub);
                showFeedError(msg, retryFn);
            } finally {
                this.classList.remove('spinning');
            }
        });

        // Event delegation for feed container (handles gallery nav, skip buttons, video tap, heart)
        document.getElementById('feed-container').addEventListener('click', (e) => {
            const target = e.target;

            // Handle skip button
            if (target.dataset.action === 'skip') {
                const index = parseInt(target.dataset.index);
                skipToNext(index);
                return;
            }

            // Handle heart button
            const heartBtn = target.closest('.heart-btn');
            if (heartBtn) {
                e.stopPropagation();
                const index = parseInt(heartBtn.dataset.index);
                const post = state.posts[index];
                if (!post) return;

                const { hearted: isNowHearted, error } = toggleFavorite(post);

                if (error) {
                    alert(error);
                    return;
                }

                const heartEmpty = `<svg viewBox="0 0 24 24" fill="none" stroke="white" stroke-width="2"><path d="M20.84 4.61a5.5 5.5 0 0 0-7.78 0L12 5.67l-1.06-1.06a5.5 5.5 0 0 0-7.78 7.78l1.06 1.06L12 21.23l7.78-7.78 1.06-1.06a5.5 5.5 0 0 0 0-7.78z"></path></svg>`;
                const heartFilled = `<svg viewBox="0 0 24 24" fill="#ff4081" stroke="#ff4081" stroke-width="2"><path d="M20.84 4.61a5.5 5.5 0 0 0-7.78 0L12 5.67l-1.06-1.06a5.5 5.5 0 0 0-7.78 7.78l1.06 1.06L12 21.23l7.78-7.78 1.06-1.06a5.5 5.5 0 0 0 0-7.78z"></path></svg>`;

                heartBtn.innerHTML = isNowHearted ? heartFilled : heartEmpty;
                heartBtn.classList.toggle('hearted', isNowHearted);

                // If un-hearting in favorites view, remove the item from current posts
                if (state.isFavorites && !isNowHearted) {
                    // Remove from current posts array
                    state.posts = state.posts.filter(p => p.id !== post.id);
                    if (state.posts.length === 0 && getFavoritesCount() === 0) {
                        goHome();
                    } else {
                        renderFeed();
                    }
                }
                return;
            }

            // Handle gallery navigation
            if (target.classList.contains('gallery-nav')) {
                e.stopPropagation();
                const index = parseInt(target.dataset.index);
                const post = state.posts[index];
                if (!post) return;

                const feedItem = target.closest('.feed-item');
                const img = feedItem.querySelector('.gallery-image');
                const indicator = feedItem.querySelector('.gallery-indicator');
                const prevBtn = feedItem.querySelector('.gallery-nav.prev');
                const nextBtn = feedItem.querySelector('.gallery-nav.next');

                let galleryIndex = parseInt(img.dataset.galleryIndex);
                const totalImages = post.media.urls.length;

                if (target.classList.contains('prev')) {
                    galleryIndex = Math.max(0, galleryIndex - 1);
                } else {
                    galleryIndex = Math.min(totalImages - 1, galleryIndex + 1);
                }

                img.src = post.media.urls[galleryIndex].url;
                img.dataset.galleryIndex = galleryIndex;
                indicator.textContent = `${galleryIndex + 1} / ${totalImages}`;

                prevBtn.style.display = galleryIndex === 0 ? 'none' : 'flex';
                nextBtn.style.display = galleryIndex === totalImages - 1 ? 'none' : 'flex';
                return;
            }

            // Handle play overlay click
            if (target.classList.contains('video-play-overlay')) {
                const feedItem = target.closest('.feed-item');
                const video = feedItem.querySelector('video');
                if (video) {
                    // Enable audio globally on first user interaction
                    audioEnabled = true;
                    video.muted = false;
                    video.play().catch(() => {});
                }
                return;
            }

            // Handle video tap to play/pause and toggle audio
            const feedItem = target.closest('.feed-item');
            if (!feedItem) return;

            // Don't toggle if clicking on buttons
            if (target.closest('button')) return;

            const video = feedItem.querySelector('video');
            if (video) {
                if (video.paused) {
                    // Enable audio globally on first user interaction
                    audioEnabled = true;
                    video.muted = false;
                    video.play().catch(() => {});
                } else {
                    // Tap while playing toggles mute
                    video.muted = !video.muted;
                    audioEnabled = !video.muted;
                }
            }
        });

        // Handle browser back/forward
        window.addEventListener('popstate', e => {
            const s = e.state;
            if (!s || s.view === 'home') {
                // Stop videos before going home
                document.querySelectorAll('video').forEach(v => {
                    v.pause();
                    v.removeAttribute('src');
                    v.load();
                });
                cleanupObserver();
                loadedMediaItems.clear();

                // Re-render home to ensure fresh subreddit list
                renderHome();
            } else if (s.view === 'feed') {
                if (s.favorites) {
                    openFavoritesFeed();
                } else if (s.mixed) {
                    openMixedFeed();
                } else if (s.sub) {
                    openFeed(s.sub);
                }
            }
        });

        // HLS toggle button
        document.getElementById('hls-toggle').addEventListener('click', function() {
            useHls = !useHls;
            this.classList.toggle('active', useHls);
        });

        // Initialize
        renderHome();
    </script>
</body>
</html>
